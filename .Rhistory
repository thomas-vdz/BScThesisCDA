k        <- length(betatrue) # set k = nr elements in beta & columns in X
sig      <- 2                # std of epsilon and y
iota     <- rep(1, n)        # column of 1's
#  Simulate explanatory X, once at the beginning, keep fixed over replications
#  Note that we use a slightly different approach to generate X
#  we'll put 1's in the first column and thus include a constant term in
#  the regression and only randomly generate X2
mux   <- (2:k)               # mean of x
sigx  <- (2:k)               # the first column in X contains 1's
X1    <- iota
X2    <- matrix(rnorm(n*(k - 1), mux, sigx), n, (k - 1), byrow = TRUE)
X     <- cbind(X1, X2)
XXinvX        <- solve(t(X)%*%X)%*%t(X)    # used in estimator b,
XXinv         <- solve(t(X)%*%X)           # used in Variance of estimator b,
diagXXinv     <- diag(XXinv)               # the diagonal elements (for the variance of b)
sqrtdiagXXinv <- sqrt(diagXXinv)
###########################################################################
#
#   simulate reps (set e.g. equal to 1000)
#   replications from the DGP with n observations
#
#   put the results for t in a (k x reps) matrix t_tsimulated
#
###########################################################################
###########################################################################
#
#  This program simulates from the CLRM and calculates the t statistic
#
#  Week 3 Computer Class, Exercise 2
#
###########################################################################
#
# Exercise 2a)
# Simulate the t-statistic (for testing H0: beta2 = 0) and illustrate its distribution when the true parameter
# i.	beta2 = 0  (i.e. the distribution under H0 : beta2 = 0)
# ii.	beta2 = 1  (i.e. the distribution under Ha : beta2 = 1)
#
# Exercise 2b)
# Calculate the probability  of rejection when the true
# i.	beta2 = 0  (this is the size H0 is true)
# ii.	beta2 = 1  (this is the power when true beta2 = 1 and thus Ha is true)
rm(list = ls()); cat("\014")       # start with clean sheet
# The model
# y = X beta + epsilon
# Set parameter values
n        <- 25               # number of observations
betatrue <- c(1, 0)          # beta parameter  H0: beta(2) = 0.
k        <- length(betatrue) # set k = nr elements in beta & columns in X
sig      <- 2                # std of epsilon and y
iota     <- rep(1, n)        # column of 1's
#  Simulate explanatory X, once at the beginning, keep fixed over replications
#  Note that we use a slightly different approach to generate X
#  we'll put 1's in the first column and thus include a constant term in
#  the regression and only randomly generate X2
mux   <- (2:k)               # mean of x
sigx  <- (2:k)               # the first column in X contains 1's
X1    <- iota
X2    <- matrix(rnorm(n*(k - 1), mux, sigx), n, (k - 1), byrow = TRUE)
X     <- cbind(X1, X2)
XXinvX        <- solve(t(X)%*%X)%*%t(X)    # used in estimator b,
XXinv         <- solve(t(X)%*%X)           # used in Variance of estimator b,
diagXXinv     <- diag(XXinv)               # the diagonal elements (for the variance of b)
sqrtdiagXXinv <- sqrt(diagXXinv)
###########################################################################
#
#   simulate reps (set e.g. equal to 1000)
#   replications from the DGP with n observations
#
#   put the results for t in a (k x reps) matrix t_tsimulated
#
###########################################################################
# betatrue parameter under H0  (do both a(i) and b(i) together since DGP is the same)
# Initialize variables for the loop to make it run faster
nrsim       <- 10000
t_simulated <- matrix(0, nrsim, k)
#  DGP   y <- X*betatrue + eps
#  repeat 1000 (reps) times
#  draw sample of size n,
#  calculate  y, b and s2  and t
#  store in a matrix
#  keep X and beta fixed (so do not change inside the loop)
#  draw new eps inside the loop
for (rr in 1:nrsim) {
eps     <- rnorm(n, 0, sig)            # draw new eps from normal distributions
y       <- X %*% betatrue + eps        # calculate new y's
betahat <- XXinvX %*% y                # calculate new betahat for this sample
e       <- y - X%*%betahat
s2      <- (sum(e*e))/(n-k)
seb     <- sqrt(s2) %*% sqrtdiagXXinv                         # this contains the s.e. of all k coefficients
# use betahat and seb as vectors to divide element-wise
tstat            <- c(betahat)/c(seb)               # this contains the t-statistics of each coefficient
t_simulated[rr,] <- tstat
}
#  for question a(1)  plot the distribution of t_2
par(mfrow = c(1, 2))
hist(t_simulated[,2], 30, freq = FALSE)         # using 30 bins relative freq distribution
#  for question b(1)  calculate the rejection probability
critical_value <- qt(0.975, n-k)           # critical value based on Student t-distribution
# for 5% two-sided test or a 2.5% one sided test
rejectH0       <- abs(t_simulated[,2]) > critical_value             # reject if |t|>critical_value
rej_p_under_H0 <- mean(rejectH0)
sprintf(' The rejection probability under H0 is %0.5g', rej_p_under_H0)
###########################################################################
#      Repeat whole process under the alternative   Ha
# ii.	beta2 = 1  (this is the distribution under Ha : beta2 = 1)
###########################################################################
betatrue    <- c(1, 1)                   # beta parameter under alternative
t_simulated <- matrix(0, nrsim, k)       # start with zero matrix
for (rr in 1:nrsim) {
eps     <- rnorm(n, 0, sig)            # draw new eps from normal distributions
y       <- X %*% betatrue + eps        # calculate new y's
betahat <- XXinvX %*% y                # calculate new betahat for this sample
e       <- y - X%*%betahat
s2      <- (sum(e*e))/(n-k)
seb     <- sqrt(s2) %*% sqrtdiagXXinv              # this contains the s.e. of all k coefficients
# use betahat and seb as vectors to divide element-wise
tstat            <- c(betahat)/c(seb)     # this contains the t-statistics of each coefficient
t_simulated[rr,] <- tstat
}
# for question a(2) plot Ha histogram in a second figure
hist(t_simulated[,2], 30, freq = FALSE)   # using 30 bins
#  for question b(2)  calculate the rejection probability
rejectH0       <- abs(tstat) > critical_value
rej_p_under_Ha <- mean(rejectH0)  # this will give rejection probability for beta2
sprintf('(i)  Size:  The rejection probability under H0 is %0.7g when beta2 = 0',rej_p_under_H0)
sprintf('(ii) Power: The rejection probability under Ha is %0.7g when beta2 = %0.5g',rej_p_under_Ha, betatrue[2])
###########################################################################
#      Repeat whole process under the alternative   Ha
# ii.	beta2 = 1  (this is the distribution under Ha : beta2 = 1)
###########################################################################
betatrue    <- c(1, 1)                   # beta parameter under alternative
t_simulated <- matrix(0, nrsim, k)       # start with zero matrix
for (rr in 1:nrsim) {
eps     <- rnorm(n, 0, sig)            # draw new eps from normal distributions
y       <- X %*% betatrue + eps        # calculate new y's
betahat <- XXinvX %*% y                # calculate new betahat for this sample
e       <- y - X%*%betahat
s2      <- (sum(e*e))/(n-k)
seb     <- sqrt(s2) %*% sqrtdiagXXinv              # this contains the s.e. of all k coefficients
# use betahat and seb as vectors to divide element-wise
tstat            <- c(betahat)/c(seb)     # this contains the t-statistics of each coefficient
t_simulated[rr,] <- tstat
}
# for question a(2) plot Ha histogram in a second figure
hist(t_simulated[,2], 30, freq = FALSE)   # using 30 bins
#  for question b(2)  calculate the rejection probability
rejectH0       <- (abs(t_simulated[,2]) > critical_value)
rej_p_under_Ha <- mean(rejectH0)  # this will give rejection probability for beta2
sprintf('(i)  Size:  The rejection probability under H0 is %0.7g when beta2 = 0',rej_p_under_H0)
sprintf('(ii) Power: The rejection probability under Ha is %0.7g when beta2 = %0.5g',rej_p_under_Ha, betatrue[2])
X = matrix(c(1,1,1,1,1,2,3,4), nrow=4, ncol=2)
View(X)
solve(t(X)%*%X)
sum(c(1,2,3,4)*c(3,7,6,9))
30*25-10*71
-10*25+10*71
-10*25+4*71
34/20
X = matrix(c(1,1,1,1,1,2,3,4), nrow=4, ncol=2)
y= c(3,7,6,9)
b=solve(t(X)%*%X)%*%t(X)%*%y
b2 = 0.918315
sb2 = 0.450532
b2/sb2
b2 = 0.918315
sb2 = 0.450532
z05 = 2.353
z025 = 3.182
z025*sb2
0.1343/2
(b2-1)/sb2
help(tnorm)
help(ttest)
"t.test"
2*pt(0.1813079)
2*pt(0.1813079,3)
2*dt(0.1813079,3)
0.061593*zo25
0.061593*z025
X = matrix(c(0,0,0,0,50,10,0,10,80),nrow=3,ncol=3)
solve(X)
View(X)
(0.3^2*(11/390))/(520/26)
(0.3757-1)/0.0853
rbq= t(r)%*% b
b = (1.1706, 0.3757, 0.6030)
r = (0,1,1)
q = 1
s2 = 0.188374^2
g = 1
rbq = 0.0213
covar = matrix(c(0.106786,0.001189,-0.019835,0.001189,0.007284,-0.009616,-0.019835,-0.009616,0.015864, nrow=3,ncol=3)
rbq = 0.0213
covar = matrix(c(0.106786,0.001189,-0.019835,0.001189,0.007284,-0.009616,-0.019835,-0.009616,0.015864), nrow=3,ncol=3)
View(covar)
r=t(c(0,0,1))
ans = (rbq^2)/(r%*%covar%*%t(r))
(r%*%covar%*%t(r))
r=c(0,0,1)
ans = (rbq^2)/(r%*%covar%*%t(r))
r=t(c(0,1,1))
ans = (rbq^2)/(r%*%covar%*%t(r))
0.1613 + 2.06*0.0575
0.1613 - 2.06*0.0575
0.3757 + 2.06*0.0853
0.3757 - 2.06*0.0853
0.6030 - 2.06*0.1260
0.6030 + 2.06*0.1260
log(2000)
s0=0.851634
s1=0.106347
s2=0.202848
((s0-s1-s2)/3)/((s1-s2)/(27-3))
((s0-s1-s2)/3)/((s1+s2)/(27-3))
((s0-s1-s2)/3)/((s1+s2)/(27-8))
((s0-s1-s2)/3)/((s1+s2)/(27-6))
58.3/21.5
help(Fq)
??FQ
help(df)
pf(0.05, 21, 31)
pf(0.95, 21, 31)
(58.3/21)/(21.5/31)
pf(0.95, 21, 31)
pf(0.05, 21, 31)
pf(0.05, 31, 31)
2
pf(0.05, 31, 21)
pf(0.95, 31, 21)
qf(0.95, 21, 31)
qf(0.95, 21, 31)
qf(0.95, 21, 31, lower.tail = TRUE)
a = function(x){
x*2
}
a(c(1,2,3,4))
View(lm.fit)
help(binom)
help(pbinom)
144/36
-62.766/27.539
s0=4888934
s1=1394689
s2= s1
s2 = 1394689
s1 = 2883170
((s0-s1-s2)/4)/((s1+s2)/(41+27-2*4))
150-3*32.5
52.5*32.5-600-30*32.5
52.5*32.5-1200-30*32.5
54/3
18/4
28/4
28/4
42-7
5/20
5/4
10-5/4
8*4
35*4
140-4
28/4
42/35
42-35
42-7
35/12
16/5
49/12
library(MASS)
fractions(1/3+5/26+555/1452)
fractions(28/12)
fractions(5/12)
fractions(36/20)
fractions((9/5)*(4/3))
2*2/3*3
2*3/3*2
(2*3)/(3*2)
fractions(16/5+4/(5*7))
80/5
80-3*16
32*16-0.5*16^2
fractions(80/3)
(4+4)^2-4^2
(4+4)*4-4^2
(4+6)*5-5^2
(4+5)*6-6^2
4+5-12
36/2
6+18
12-36+24
12-24+36
24^2
12-18+15
12+18-15
15^15
15*15
18*9
library(MASS)
library(MOSS)
fractions(9*(4/3))
fractions(12*(3/2))
fractions((1/3)*(3/2))
6*24
(12+36)*12
fractions(25.33333333333333333333333/2)
11/2-11+18
12.5*7
fractions((27/2)*(4/3))
7000*10*0.005
points = c(0,1,2,1,3,1)
total = c(4,1,3,2,4,1)
sum(points)/sum(total)
sum(total)
sum(points)
points = c(0,1,2,1,3,1)
total = c(4,1,3,2,4,1)
18/25
0.25*7.2+0.75*5
0.25*6.7+0.75*5
0.25*6.75+0.75*5
16/25
17/25
18/25
0.1148/2
3.101-2*0.288+0.798
2.783+1.336
4.119^2
3.323
16.96616/3.323
0.016695*1.17e08
48/4
48-3*8
8*24
24*8-8^2
48/3
48-144/11-96/11
144/11-96/11
144/11+96/11
rm(list = ls())
help(ln)
help(lm)
## estimator of the variance of error terms
s2= sum(lm$residuals^2)/lm$df.residual
results[i,2]=sqrt(n)*(reg$coefficients[2]-beta)
## set a seed for RND
set.seed(14285)
## set a seed for RND
set.seed(14285)
## intercept coefficient
alpha = -1
## slope coefficient
beta = 1
## correlation between regressor and error term
rho = 0.0
## rho = 0.5
## sample size
n = 25
n = 100
print("Sample size")
print(n)
## trend vector (1:n)'
trend = 1:n
k=2
## number replications
R = 10000
print("Correlation b/w x and eps")
print(rho)
## initialize a matrix of the estimation results in R replications
results = matrix(0,R,3)
## choose values for x, which are not stable
x = trend
## x = 1/trend
for (i in 1:R){
eps = rnorm(n)
eta = rnorm(n)
## generate stable random x
## x = sqrt(1-rho^2)*eta + rho*eps
## generate y
y = alpha + beta*x + eps
reg=lm(y~1+x)
## estimator of the variance of error terms
s2= sum(reg$residuals^2)/reg$df.residual
results[i,1]=reg$coefficients[2]
results[i,2]=sqrt(n)*(reg$coefficients[2]-beta)
results[i,3]=s2
}
## estimated OLS slope parameters
b=results[,1]
## estimated normalized OLS slope parameters
bnorm=results[,2]
## estimated variances of error terms
s2=results[,3]
hist(b,breaks=40)
hist(bnorm,breaks=40)
hist(s2,breaks=40)
print("Mean of b")
print(mean(b))
print("St. dev of b")
print(sd(b))
print("Mean of bnorm")
print(mean(bnorm))
print("St. dev of b")
print(sd(bnorm))
print("Mean of s2")
print(mean(s2))
print("St. dev of s2")
print(sd(s2))
reg$df.residual
sum(reg$residuals^2)
## generate stable random x
x = sqrt(1-rho^2)*eta + rho*eps
## set a seed for RND
set.seed(14285)
## intercept coefficient
alpha = -1
## slope coefficient
beta = 1
## correlation between regressor and error term
rho = 0.0
rho = 0.5
## sample size
n = 25
n = 100
print("Sample size")
print(n)
## trend vector (1:n)'
trend = 1:n
k=2
## number replications
R = 10000
print("Correlation b/w x and eps")
print(rho)
## initialize a matrix of the estimation results in R replications
results = matrix(0,R,3)
## choose values for x, which are not stable
x = trend
## x = 1/trend
for (i in 1:R){
eps = rnorm(n)
eta = rnorm(n)
## generate stable random x
x = sqrt(1-rho^2)*eta + rho*eps
## generate y
y = alpha + beta*x + eps
reg=lm(y~1+x)
## estimator of the variance of error terms
s2= sum(reg$residuals^2)/reg$df.residual
results[i,1]=reg$coefficients[2]
results[i,2]=sqrt(n)*(reg$coefficients[2]-beta)
results[i,3]=s2
}
## estimated OLS slope parameters
b=results[,1]
## estimated normalized OLS slope parameters
bnorm=results[,2]
## estimated variances of error terms
s2=results[,3]
hist(b,breaks=40)
hist(bnorm,breaks=40)
hist(s2,breaks=40)
print("Mean of b")
print(mean(b))
print("St. dev of b")
print(sd(b))
print("Mean of bnorm")
print(mean(bnorm))
print("St. dev of b")
print(sd(bnorm))
print("Mean of s2")
print(mean(s2))
print("St. dev of s2")
print(sd(s2))
R = c(0,0,0,619.822, -80.69258, 0)
b = c(0,0,0,3728.939, 439.1485,0 )
s2= 3014.947^2
R%*%b
Rb = R%*%B
Rb = R%*%b
sqrt(384179)
R = c(0,0,0,0.541420, -5.928394, 0)
b = c(0,0,0,3728.939, 439.1485,0 )
Rb = R%*%b
s2= 3014.947^2
rb
Rb
0.541420*384179.3  - 5.928394*-10695.58 + 0.541420*-10695.58  - 5.928394*6511.292
0.541420*384179.3  - 5.928394*-10695.58
0.541420*-10695.58  - 5.928394*6511.292
0.541420*271410  - 5.928394*-44392.31
(584.52^2)/ 410122
library("tidyverse")
install.packages(tidyverse, dependencies = TRUE)
install.packages("tidyverse", dependencies = TRUE)
#Makes sure the working directory is the same directory as the file is in
library("rstudioapi")
library("tidyverse")
setwd(dirname(getActiveDocumentContext()$path))
#Open file
data = read.csv("util.csv")
#Makes sure the working directory is the same directory as the file is in
library("rstudioapi")
library("tidyverse")
setwd(dirname(getActiveDocumentContext()$path))
#Open file
data = read.csv("util.csv")
View(data)
data$x = data$time + (data$period-1)
data$x = data$time + (data$period-1)*300
#Price over time
p = ggplot(data, aes(x = x, y= x))
install.packages("ggplot2")
library("ggplot2")
