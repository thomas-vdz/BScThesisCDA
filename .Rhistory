for (j in 1:nr_of_H1_values) {
nreject <- 0
show(beta[2] <- beta2vec[j])       # make this beta(2) the value under the DGP
for (i in 1:nrsim) {
eps  <- rnorm(n, 0, sig)
y    <- X %*% beta + eps
b    <- XXinv %*% t(X) %*% y
e    <- y - X %*% b
s2   <- sum(e * e) / (n - k)
seb2 <- sqrt(s2) * sqrt(XXinv[2,2])
t    <- abs(b[2]/seb2) # write the appropriate test statistic
if (t > critical_value){       # then reject the null hypothesis
nreject <- nreject + 1         # count how often this occurs
}
}
power[j] <- nreject / nrsim        # count how many rejections out of nrsim tries
}
plot(beta2vec, power, type = "b", col="red")
abline(0.05, 0, col = "blue")
## Exercise 2c
#  run this script with a different n
#  run this script with a different sig but original n
if (t > critical_value){       # then reject the null hypothesis
nreject <- nreject + 1         # count how often this occurs
}
####################################################################
#
# This program simulates the POWER of the t-test in the CLRM
# y <- X beta + epsilon
#
####################################################################
rm(list = ls()); cat("\014") # Clear memory and screen
set.seed(2021)               # Set random seed
# Set parameter values
n    <- 125          # number of observations
k    <-  2           # number of regressors elements in X
iota <- rep(1, n)
beta <- c(0.01, 2)   # beta parameter
mux  <- c(1, 10)     # mean of x
sigx <- c(0, 2)      # the first column in X contains 1's
sig  <- 6            # std of epsilon and y
sig2 <- sig^2        # variance of epsilon and y
# simulate explanatory  X
X    <- matrix(rnorm(n * k, mux, sigx), n, k, byrow = TRUE)
## Simulation
nrsim <- 5000
nr_of_H1_values <- 31 # nr of points where we're going to evaluate power
# DGP   y = X*beta +eps
# keep X and beta fixed and draw new eps
XXinv <- solve(t(X)%*%X)             # we only have to calculate the inverse only once
critical_value <- qt(0.95, n-k)      # (one-sided) critical based on Student t-distribution
sprintf('Critical value is %.4f', critical_value)
power    <- rep(0, nr_of_H1_values)  # store power in this matrix for each value under H1
beta2vec <- seq(1.5, 3.0, length.out = nr_of_H1_values)  # the values of beta under H1
for (j in 1:nr_of_H1_values) {
nreject <- 0
show(beta[2] <- beta2vec[j])       # make this beta(2) the value under the DGP
for (i in 1:nrsim) {
eps  <- rnorm(n, 0, sig)
y    <- X %*% beta + eps
b    <- XXinv %*% t(X) %*% y
e    <- y - X %*% b
s2   <- sum(e * e) / (n - k)
seb2 <- sqrt(s2) * sqrt(XXinv[2,2])
t    <- abs((b[2]-2)/seb2) # write the appropriate test statistic
if (t > critical_value){       # then reject the null hypothesis
nreject <- nreject + 1         # count how often this occurs
}
}
power[j] <- nreject / nrsim        # count how many rejections out of nrsim tries
}
plot(beta2vec, power, type = "b", col="red")
abline(0.05, 0, col = "blue")
## Exercise 2c
#  run this script with a different n
#  run this script with a different sig but original n
range(10)
range(0,10)
func = function(x){return x^2}
sum(func(1:10))
func = function(x){x^2}
sum(func(1:10))
func = function(x){365/x^2}
sum(func(1:10))
func = function(x){365/x^2}
func(1:10)
func = function(x){1/x^2}
func(1:10)
func = function(x){1/x^2}
0.1/sum(func(1:10))
func = function(x){0.0645258/x^2}
s=func(1:10)
view(s)
bb = matrix(s, nrow=1,ncol=10)
View(bb)
bb = matrix(s, ncol=1,nrow=10)
5555*36
tot = 5555*36
32/6
32/2
a = data.matrix(c(13,76,37,16,66,12), nrow=2, ncol=3)
a = data.frame(c(13,76,37,16,66,12), nrow=2, ncol=3)
View(a)
a = matrix(c(13,76,37,16,66,12), nrow=2, ncol=3)
View(a)
help(matrix)
a = matrix(c(13,76,37,16,66,12), nrow=2, ncol=3, byrow= TRUE)
View(a)
chisq <- chisq.test(a)
chisq$statistic
b = matrix(c(7,22,23,9,15,10,15,14), nrow=2, ncol=4, byrow= TRUE)
chisq2 <- chisq.test(b)
chisq2$statistic
help("chisq.test")
#Makes sure the working directory is the same directory as the file is in
library("rstudioapi")
library("ggplot2")
library("tidyverse")
library("dplyr")
library("padr")
setwd(dirname(getActiveDocumentContext()$path))
#Run data
runs = 10
periods = 5
endtime = 150
#Function so we can read the latest csv file that has been generated.
# f(...) indicates we can pass any parameter into list.files
most_recent = function(...) {
tail(list.files(...), 1)
}
#----------------- Average Utility Plot ---------------------
#Open the most recent util.csv file in the results folder.
util_data = read.csv( paste0("results/",most_recent(path="results", pattern="util")) )
util_data = util_data[!(util_data$time == 1  & util_data$period == 1), ]
#Add x values for plotting
util_data$x = (util_data$time + (util_data$period-1)*endtime)
util_data$avg_util = ifelse(util_data$time  == 1, NA , util_data$avg_util)
#Convert ttype to string
util_data$ttype = as.character(util_data$ttype)
#Utility over time
ggplot(util_data, aes(x = x, y= avg_util, colour= ttype, linetype=talgo  ))+
geom_line(size=0.75) +
ylab("Average utility level") +
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5")) +
theme(
legend.text = element_text(size = 12),
panel.background = element_rect(fill = "#BFD5E3", colour = "#6D9EC1",
size = 2, linetype = "solid"),
panel.grid.major = element_line(size = 0.5, linetype = 'solid',
colour = "white"),
panel.grid.minor = element_line(size = 0.25, linetype = 'solid',
colour = "white"),
axis.text.x = element_text(face="bold", color="#000000",
size=14, angle=45)
)
#----------------- Trade/Price Plot ---------------------
trade_data = read.csv( paste0("results/",most_recent(path="results", pattern="trade")) )
trade_data$x = trade_data$time + trade_data$time*(trade_data$period-1)
#Make unique id for each timestep at each run
trade_data$id = (trade_data$x + (trade_data$run-1)*(periods*endtime))
#Separate x,y pricedata
trade_data_x = trade_data[ trade_data$ptype == "X", c("time", "price", 'ptype', 'x', 'id') ]
#Average prices per unique timestep
avg_price_x = tibble( unique( group_by(trade_data_x, id) %>% summarize(price = mean(price), x = x) ), .name_repair = make.unique )
#Fill in the missing ID's
avg_price_x = pad_int(avg_price_x, "id")
#If there is no price set is to the last known price
avg_price_x  = fill(avg_price_x , price)
#Get the correct x values
avg_price_x$x = ifelse(is.na(avg_price_x$x)==TRUE, avg_price_x$id %% (periods*endtime) , avg_price_x$x)
#Now calculate std deviation/
stats_x = data.frame(matrix(ncol=5,nrow=periods*endtime))
colnames(stats_x) = c("x","mean","stddev","lowerbound","upperbound")
#Calculate 95% confidence interval for each unique timestep
for (i in 1:(periods*endtime -1)){
#Get all obs with x = i
prices = avg_price_x[avg_price_x$x == i,]$price
m = mean(prices)
sd = sqrt(var(prices))
n = length(prices)
error = qt(0.975, df=n-1)*sd/sqrt(n)
lower = m - error
upper = m + error
row = c(i, m, sd, lower, upper)
stats_x[i,] = row
}
ggplot(stats_x, aes(x = x))+
ggtitle("X")+
geom_line(aes(y = mean, colour= "Mean"))+
geom_ribbon(aes(ymin=lowerbound, ymax=upperbound, x=x, fill = "band"), alpha = 0.3)+
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5"))
# Y DATA
trade_data_y = trade_data[ trade_data$ptype == "Y", ]
#Separate x,y pricedata
trade_data_y = trade_data[ trade_data$ptype == "Y", c("time", "price", 'ptype', 'x', 'id') ]
#Average prices per unique timestep
avg_price_y = tibble( unique( group_by(trade_data_y, id) %>% summarize(price = mean(price), x = x) ), .name_repair = make.unique )
#Fill in the missing ID's
avg_price_y = pad_int(avg_price_y, "id")
#If there is no price set is to the last known price
avg_price_y  = fill(avg_price_y , price)
#Get the correct x values
avg_price_y$x = ifelse(is.na(avg_price_y$x)==TRUE, avg_price_y$id %% (periods*endtime) , avg_price_y$x)
#Now calculate std deviation/
stats_y = data.frame(matrix(ncol=5,nrow=periods*endtime))
colnames(stats_y) = c("x","mean","stddev","lowerbound","upperbound")
#Calculate 95% confidence interval for each unique timestep
for (i in 1:(periods*endtime -1)){
#Get all obs with x = i
prices = avg_price_y[avg_price_y$x == i,]$price
m = mean(prices)
sd = sqrt(var(prices))
n = length(prices)
error = qt(0.975, df=n-1)*sd/sqrt(n)
lower = m - error
upper = m + error
row = c(i, m, sd, lower, upper)
stats_y[i,] = row
}
ggplot(stats_y, aes(x = x))+
ggtitle("Y")+
geom_line(aes(y = mean, colour= "Mean"))+
geom_ribbon(aes(ymin=lowerbound, ymax=upperbound, x=x, fill = "band"), alpha = 0.3)+
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5"))
#----------------- Excess Plot ---------------------
excess_data = read.csv( paste0("results/",most_recent(path="results", pattern="excess")))
#Convert ttype to string
excess_data$ttype = as.character(excess_data$ttype)
#Gives the average excess per period/algorithm/tradertype
average_excess = group_by(excess_data, ttype, talgo, period) %>% summarize(money = mean(money), X = mean(X), Y = mean(Y))
#Sort by period
average_excess = average_excess[order(average_excess$period),]
average_excess
ggplot(average_excess , aes(x = period, y= money, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
ggplot(average_excess , aes(x = period, y= X, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
ggplot(average_excess , aes(x = period, y= Y, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
View(trade_data)
#Makes sure the working directory is the same directory as the file is in
library("rstudioapi")
library("ggplot2")
library("tidyverse")
library("dplyr")
library("padr")
setwd(dirname(getActiveDocumentContext()$path))
#Run data
runs = 10
periods = 5
endtime = 150
#Function so we can read the latest csv file that has been generated.
# f(...) indicates we can pass any parameter into list.files
most_recent = function(...) {
tail(list.files(...), 1)
}
#----------------- Average Utility Plot ---------------------
#Open the most recent util.csv file in the results folder.
util_data = read.csv( paste0("results/",most_recent(path="results", pattern="util")) )
util_data = util_data[!(util_data$time == 1  & util_data$period == 1), ]
#Add x values for plotting
util_data$x = (util_data$time + (util_data$period-1)*endtime)
util_data$avg_util = ifelse(util_data$time  == 1, NA , util_data$avg_util)
#Convert ttype to string
util_data$ttype = as.character(util_data$ttype)
#Utility over time
ggplot(util_data, aes(x = x, y= avg_util, colour= ttype, linetype=talgo  ))+
geom_line(size=0.75) +
ylab("Average utility level") +
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5")) +
theme(
legend.text = element_text(size = 12),
panel.background = element_rect(fill = "#BFD5E3", colour = "#6D9EC1",
size = 2, linetype = "solid"),
panel.grid.major = element_line(size = 0.5, linetype = 'solid',
colour = "white"),
panel.grid.minor = element_line(size = 0.25, linetype = 'solid',
colour = "white"),
axis.text.x = element_text(face="bold", color="#000000",
size=14, angle=45)
)
#----------------- Trade/Price Plot ---------------------
trade_data = read.csv( paste0("results/",most_recent(path="results", pattern="trade")) )
trade_data$x = trade_data$time + trade_data$time*(trade_data$period-1)
#Make unique id for each timestep at each run
trade_data$id = (trade_data$x + (trade_data$run-1)*(periods*endtime))
#Separate x,y pricedata
trade_data_x = trade_data[ trade_data$ptype == "X", c("time", "price", 'ptype', 'x', 'id') ]
#Average prices per unique timestep
avg_price_x = tibble( unique( group_by(trade_data_x, id) %>% summarize(price = mean(price), x = x) ), .name_repair = make.unique )
#Fill in the missing ID's
avg_price_x = pad_int(avg_price_x, "id")
#If there is no price set is to the last known price
avg_price_x  = fill(avg_price_x , price)
#Get the correct x values
avg_price_x$x = ifelse(is.na(avg_price_x$x)==TRUE, avg_price_x$id %% (periods*endtime) , avg_price_x$x)
#Now calculate std deviation/
stats_x = data.frame(matrix(ncol=5,nrow=periods*endtime))
colnames(stats_x) = c("x","mean","stddev","lowerbound","upperbound")
#Calculate 95% confidence interval for each unique timestep
for (i in 1:(periods*endtime -1)){
#Get all obs with x = i
prices = avg_price_x[avg_price_x$x == i,]$price
m = mean(prices)
sd = sqrt(var(prices))
n = length(prices)
error = qt(0.975, df=n-1)*sd/sqrt(n)
lower = m - error
upper = m + error
row = c(i, m, sd, lower, upper)
stats_x[i,] = row
}
ggplot(stats_x, aes(x = x))+
ggtitle("X")+
geom_line(aes(y = mean, colour= "Mean"))+
geom_ribbon(aes(ymin=lowerbound, ymax=upperbound, x=x, fill = "band"), alpha = 0.3)+
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5"))
# Y DATA
trade_data_y = trade_data[ trade_data$ptype == "Y", ]
#Separate x,y pricedata
trade_data_y = trade_data[ trade_data$ptype == "Y", c("time", "price", 'ptype', 'x', 'id') ]
#Average prices per unique timestep
avg_price_y = tibble( unique( group_by(trade_data_y, id) %>% summarize(price = mean(price), x = x) ), .name_repair = make.unique )
#Fill in the missing ID's
avg_price_y = pad_int(avg_price_y, "id")
#If there is no price set is to the last known price
avg_price_y  = fill(avg_price_y , price)
#Get the correct x values
avg_price_y$x = ifelse(is.na(avg_price_y$x)==TRUE, avg_price_y$id %% (periods*endtime) , avg_price_y$x)
#Now calculate std deviation/
stats_y = data.frame(matrix(ncol=5,nrow=periods*endtime))
colnames(stats_y) = c("x","mean","stddev","lowerbound","upperbound")
#Calculate 95% confidence interval for each unique timestep
for (i in 1:(periods*endtime -1)){
#Get all obs with x = i
prices = avg_price_y[avg_price_y$x == i,]$price
m = mean(prices)
sd = sqrt(var(prices))
n = length(prices)
error = qt(0.975, df=n-1)*sd/sqrt(n)
lower = m - error
upper = m + error
row = c(i, m, sd, lower, upper)
stats_y[i,] = row
}
ggplot(stats_y, aes(x = x))+
ggtitle("Y")+
geom_line(aes(y = mean, colour= "Mean"))+
geom_ribbon(aes(ymin=lowerbound, ymax=upperbound, x=x, fill = "band"), alpha = 0.3)+
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5"))
#----------------- Excess Plot ---------------------
excess_data = read.csv( paste0("results/",most_recent(path="results", pattern="excess")))
#Convert ttype to string
excess_data$ttype = as.character(excess_data$ttype)
#Gives the average excess per period/algorithm/tradertype
average_excess = group_by(excess_data, ttype, talgo, period) %>% summarize(money = mean(money), X = mean(X), Y = mean(Y))
#Sort by period
average_excess = average_excess[order(average_excess$period),]
average_excess
ggplot(average_excess , aes(x = period, y= money, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
ggplot(average_excess , aes(x = period, y= X, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
ggplot(average_excess , aes(x = period, y= Y, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
#Makes sure the working directory is the same directory as the file is in
library("rstudioapi")
library("ggplot2")
library("tidyverse")
library("dplyr")
library("padr")
setwd(dirname(getActiveDocumentContext()$path))
#Run data
runs = 10
periods = 5
endtime = 150
#Function so we can read the latest csv file that has been generated.
# f(...) indicates we can pass any parameter into list.files
most_recent = function(...) {
tail(list.files(...), 1)
}
#----------------- Average Utility Plot ---------------------
#Open the most recent util.csv file in the results folder.
util_data = read.csv( paste0("results/",most_recent(path="results", pattern="util")) )
util_data = util_data[!(util_data$time == 1  & util_data$period == 1), ]
#Add x values for plotting
util_data$x = (util_data$time + (util_data$period-1)*endtime)
util_data$avg_util = ifelse(util_data$time  == 1, NA , util_data$avg_util)
#Convert ttype to string
util_data$ttype = as.character(util_data$ttype)
#Utility over time
ggplot(util_data, aes(x = x, y= avg_util, colour= ttype, linetype=talgo  ))+
geom_line(size=0.75) +
ylab("Average utility level") +
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5")) +
theme(
legend.text = element_text(size = 12),
panel.background = element_rect(fill = "#BFD5E3", colour = "#6D9EC1",
size = 2, linetype = "solid"),
panel.grid.major = element_line(size = 0.5, linetype = 'solid',
colour = "white"),
panel.grid.minor = element_line(size = 0.25, linetype = 'solid',
colour = "white"),
axis.text.x = element_text(face="bold", color="#000000",
size=14, angle=45)
)
#----------------- Trade/Price Plot ---------------------
trade_data = read.csv( paste0("results/",most_recent(path="results", pattern="trade")) )
trade_data$x = trade_data$time + trade_data$time*(trade_data$period-1)
#Make unique id for each timestep at each run
trade_data$id = (trade_data$x + (trade_data$run-1)*(periods*endtime))
#Separate x,y pricedata
trade_data_x = trade_data[ trade_data$ptype == "X", c("time", "price", 'ptype', 'x', 'id') ]
#Average prices per unique timestep
avg_price_x = tibble( unique( group_by(trade_data_x, id) %>% summarize(price = mean(price), x = x) ), .name_repair = make.unique )
#Fill in the missing ID's
avg_price_x = pad_int(avg_price_x, "id")
#If there is no price set is to the last known price
avg_price_x  = fill(avg_price_x , price)
#Get the correct x values
avg_price_x$x = ifelse(is.na(avg_price_x$x)==TRUE, avg_price_x$id %% (periods*endtime) , avg_price_x$x)
#Now calculate std deviation/
stats_x = data.frame(matrix(ncol=5,nrow=periods*endtime))
colnames(stats_x) = c("x","mean","stddev","lowerbound","upperbound")
#Calculate 95% confidence interval for each unique timestep
for (i in 1:(periods*endtime -1)){
#Get all obs with x = i
prices = avg_price_x[avg_price_x$x == i,]$price
m = mean(prices)
sd = sqrt(var(prices))
n = length(prices)
error = qt(0.975, df=n-1)*sd/sqrt(n)
lower = m - error
upper = m + error
row = c(i, m, sd, lower, upper)
stats_x[i,] = row
}
ggplot(stats_x, aes(x = x))+
ggtitle("X")+
geom_line(aes(y = mean, colour= "Mean"))+
geom_ribbon(aes(ymin=lowerbound, ymax=upperbound, x=x, fill = "band"), alpha = 0.3)+
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5"))
# Y DATA
trade_data_y = trade_data[ trade_data$ptype == "Y", ]
#Separate x,y pricedata
trade_data_y = trade_data[ trade_data$ptype == "Y", c("time", "price", 'ptype', 'x', 'id') ]
#Average prices per unique timestep
avg_price_y = tibble( unique( group_by(trade_data_y, id) %>% summarize(price = mean(price), x = x) ), .name_repair = make.unique )
#Fill in the missing ID's
avg_price_y = pad_int(avg_price_y, "id")
#If there is no price set is to the last known price
avg_price_y  = fill(avg_price_y , price)
#Get the correct x values
avg_price_y$x = ifelse(is.na(avg_price_y$x)==TRUE, avg_price_y$id %% (periods*endtime) , avg_price_y$x)
#Now calculate std deviation/
stats_y = data.frame(matrix(ncol=5,nrow=periods*endtime))
colnames(stats_y) = c("x","mean","stddev","lowerbound","upperbound")
#Calculate 95% confidence interval for each unique timestep
for (i in 1:(periods*endtime -1)){
#Get all obs with x = i
prices = avg_price_y[avg_price_y$x == i,]$price
m = mean(prices)
sd = sqrt(var(prices))
n = length(prices)
error = qt(0.975, df=n-1)*sd/sqrt(n)
lower = m - error
upper = m + error
row = c(i, m, sd, lower, upper)
stats_y[i,] = row
}
ggplot(stats_y, aes(x = x))+
ggtitle("Y")+
geom_line(aes(y = mean, colour= "Mean"))+
geom_ribbon(aes(ymin=lowerbound, ymax=upperbound, x=x, fill = "band"), alpha = 0.3)+
xlab("Period") +
scale_x_continuous(breaks=seq(0,endtime*periods,endtime), labels=c("0","1","2","3","4","5"))
#----------------- Excess Plot ---------------------
excess_data = read.csv( paste0("results/",most_recent(path="results", pattern="excess")))
#Convert ttype to string
excess_data$ttype = as.character(excess_data$ttype)
#Gives the average excess per period/algorithm/tradertype
average_excess = group_by(excess_data, ttype, talgo, period) %>% summarize(money = mean(money), X = mean(X), Y = mean(Y))
#Sort by period
average_excess = average_excess[order(average_excess$period),]
average_excess
ggplot(average_excess , aes(x = period, y= money, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
ggplot(average_excess , aes(x = period, y= X, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
ggplot(average_excess , aes(x = period, y= Y, colour= ttype, linetype=talgo  ))+
geom_point(size=3)+
geom_line(size=0.75)
t = trade_data[trade_data$arbitrage == TRUE,]
View(trade_data)
t = trade_data[trade_data$arbitrage == "True",]
View(t)
